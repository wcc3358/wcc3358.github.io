(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{268:function(t,s,a){"use strict";a.r(s);var v=a(0),_=Object(v.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"第08章-装饰者模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第08章-装饰者模式"}},[t._v("#")]),t._v(" 第08章 装饰者模式")]),t._v(" "),a("p",[t._v("大纲")]),t._v(" "),a("ul",[a("li",[t._v("为什么要使用装饰者模式？")]),t._v(" "),a("li",[t._v("装饰者模式的概念及适应环境")]),t._v(" "),a("li",[t._v("装饰者模式的结构")]),t._v(" "),a("li",[t._v("装饰者模式实例演示")]),t._v(" "),a("li",[t._v("装饰者模式的优缺点")]),t._v(" "),a("li",[t._v("总结")])]),t._v(" "),a("h2",{attrs:{id:"为什么要使用装饰者模式？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用装饰者模式？"}},[t._v("#")]),t._v(" 为什么要使用装饰者模式？")]),t._v(" "),a("p",[t._v("老王是一个豆浆店的老板，因为豆浆品种多，生意火爆，我看着老王赚钱比较眼馋，晚上和他套近乎喝了点啤酒，老王就把配方分享给我了，具体配方如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"assets/1571843771966.png",alt:"1571843771966"}})]),t._v(" "),a("p",[t._v("最终可以搭配出的豆浆品种为：")]),t._v(" "),a("p",[a("img",{attrs:{src:"assets/1571843797958.png",alt:"1571843797958"}})]),t._v(" "),a("p",[t._v("现在想要新增一种辅料西瓜：")]),t._v(" "),a("p",[a("img",{attrs:{src:"assets/1571843841837.png",alt:"1571843841837"}})]),t._v(" "),a("p",[t._v("搭配的豆浆品种就更多了")]),t._v(" "),a("p",[a("img",{attrs:{src:"assets/1571843875775.png",alt:"1571843875775"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"assets/1571843920808.png",alt:"1571843920808"}})]),t._v(" "),a("p",[t._v("程序可能变得很臃肿")]),t._v(" "),a("p",[t._v("这里我们看到，如果使用子类继承父类，那么我们要写很多子类，这么做无疑增加了程序的臃肿性，并不是很灵活。此时，装饰者模式就诞生了。")]),t._v(" "),a("h2",{attrs:{id:"装饰者模式的概念及适应场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#装饰者模式的概念及适应场景"}},[t._v("#")]),t._v(" 装饰者模式的概念及适应场景")]),t._v(" "),a("h3",{attrs:{id:"概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),a("p",[t._v("装饰者模式又名包装模式。动态给一个对象添加一些额外的职责。就扩展功能而言，比生成子类的方式更为灵活。")]),t._v(" "),a("p",[t._v("注意：动态（运行时）  额外的职责（增强）")]),t._v(" "),a("h3",{attrs:{id:"适应场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适应场景"}},[t._v("#")]),t._v(" 适应场景")]),t._v(" "),a("p",[t._v("以动态的方式给对象添加职责（相较于继承）；")]),t._v(" "),a("p",[t._v("处理那些可以撤销的职责；")]),t._v(" "),a("p",[t._v("当采用生成子类的方法进行扩展时，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类的数目呈爆炸性增长；")]),t._v(" "),a("h2",{attrs:{id:"装饰者模式结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#装饰者模式结构"}},[t._v("#")]),t._v(" 装饰者模式结构")]),t._v(" "),a("ul",[a("li",[t._v("抽象组件（Component）:给出一个抽象接口，以规范准备接受附加责任的对象；")]),t._v(" "),a("li",[t._v("被装饰者（ConcreteComponent）:Component的具体实现，也就是我们要装饰的具体对象；")]),t._v(" "),a("li",[t._v("装饰者组件（Decorator）:持有组件（Component）对象的实例引用，该类的职责就是为了装饰具体组件对象定义的基类；")]),t._v(" "),a("li",[t._v("具体装饰（ConcreteDecorator）:负责给构件对象装饰附加的功能；")])]),t._v(" "),a("p",[a("img",{attrs:{src:"assets/1571844971493.png",alt:"1571844971493"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"assets/1571844981283.png",alt:"1571844981283"}})])])}),[],!1,null,null,null);s.default=_.exports}}]);